How Promise Works (from the [Stronger Promises Whitepaper](https://github.com/Promise-Protocol/Documentation/blob/master/Reference%20Papers/Stronger_Promises.pdf))
-------------------

Types of Promise Pubic Keys
-------------------

Promise distinguishes 5 types of data structures that are or hold public keys on the network.

### Address Public Key

An *address public key*, or *address* for short, is a pair (*spk, epk*)
where:
-   *spk* is the public key of a signature scheme with public key re-randomization. In particular, Promise uses the [LUOV](https://github.com/Promise-Protocol/Documentation/blob/master/Reference%20Papers/luov.pdf) scheme with re-randomization based on the IP problem.
-   *epk* is the public key of an encryption scheme with ciphertext / public key unlinkability. Promise uses [NewHope](https://github.com/Promise-Protocol/Documentation/blob/master/Reference%20Papers/NewHope_2015-1092.pdf).

Address public keys are used to receive payments. In particular, the *mast hash* of a UTXO generally hides a script that asks to verify a signature on the next transaction under a given public key; this public key is a re-randomization of *spk*; the randomness used for this re-randomization is encrypted under *epk*.

### Identity Public Key

*Identity public keys* are used exclusively in the context of the Pledge, the re-payment or borrower contract primitive in the Promise Protocol. They are used to identify the parties to the Pledge, verify their agreement to it, and compute payment reputations from Pledge transactions. Identity public keys are long-lived. Ideally, every user has one identity public key for their entire life cycle.

*Authorizer public keys* are used to limit who can pay into a Pledge. If the payment clause identifies an authorizer public key, then an incoming payment that satisfies the clause must bear a signature valid under that public key. Otherwise the transaction is not valid. Authorizer public keys are typically one-time keys: they are not reused across Pledges but new authorizer public keys are generated for new Pledges instead.

Identity public keys and authorizer public keys are public keys from the same signature scheme, which supports proxy re-signing. This property enables Alice to sign in Bob’s name, given some proxy information generated by Bob. With respect to payments to the Pledge, this property allows Alice to make payments, sign them with her own identity secret key, and then transform the resulting signature into one that is valid under the authorizer public key. In other words, this property guarantees that only authorized parties (*i.e.*, those that have received the proxy information) can make payments.

How Promise Transactions Work
---------------------

### Ephemeral UTXOs

In Promise, the *unspent transaction outputs (UTXOs)* are *ephemeral* because they are used once and then discarded, just like the key in ephemeral key exchange protocols. Specifically, ephemeral UTXOs are unlinkable to the address they transfer coins to. This is accomplished by two elements: a signature scheme with public key re-randomization, and a public key encryption scheme with ciphertext / public key unlinkability. The ingredients for confidential transactions are in
place: a commitment scheme to hide the amount of coins being transferred, and zero-knowledge proofs to establish that no new coins are being created. Technically though, the zero-knowledge proofs are part of the transaction and not the UTXOs.

### Script, MAST, and mast\_hash

The script determines whether a transaction is valid or not. In particular, each input UTXO commits to a script which evaluates to True or to False. The transaction is valid only if all the scripts of all the input UTXOs evaluate to True.

Any node in the script’s abstract syntax tree can be replaced by the hash

*h* = H(*node type *||* value*)

where:

-   *node type* represents the node’s function in the abstract syntax
    tree, *e.g.*, identifier or logical AND operator or string literal,
    *etc*.
-   *Value* is the MAST root of the entire branch below the given node,
    or else the script code of that entire branch. If the node type is a
    string literal or number then the node’s value is exactly this
    value.

As a result, the tree is simultaneously an abstract syntax tree and a
Merkle tree: the root is a cryptographic commitment to the entire tree.
The data structure is called Merkelized Abstract Syntax Tree, or *MAST*
for short.

The purpose of this replacement is to make it possible to show that a
script evaluates to True without revealing all of it. When only some
branches of the abstract syntax tree are needed to show that the script
evaluates to True, the other branches may be hidden behind their hashes.

The *mast\_hash* field of a UTXO represents the root of such a MAST.

Whenever a *mast\_hash* is opened to an authentication path and some
terminal node in the resulting abstract syntax branch is an argument
variable, then an assignment to this variable must additionally be
provided. Otherwise the script cannot be evaluated because its value
depends on the value of undetermined variables.

### Step-by-step

Suppose Alice has 30 coins and wants to send 10 of them to Bob. She
transfers them by following the following steps.

1.  Alice obtains Bob’s *address public key*, which consists of a
    signature and an encryption public key.
2.  Alice generates a UTXO for Bob. This step decomposes into:

    a.  Alice generates a commitment to the number 10 (the number of
        coins); this output is *amt*.

    b.  Alice chooses a sufficiently long random bitstring *randomness*.

    c.  Alice re-randomizes Bob’s signature public key using this
        *randomness*; this output is *rspk*.

    d.  Alice encrypts this randomness with Bob’s encryption public key;
        this output is *ctxt = E*~*epk*~*(randomness)*.

    e.  Alice generates a script: “VerifySig(*rspk*, \$transaction,
        \$signature)” where *rspk *is hardcoded and takes the value of
        the re-randomized signature public key. Alice computes
        *mast\_hash* as the hash of this script.

    f.  The UTXO for Bob is the tuple (*amt, ctxt, mast\_hash*).

3.  Similarly, Alice generates a UTXO for herself, to represent the
    change. Since the change is 20 coins, the commitment here is to the
    number 20. Also, she uses her own address public key rather than
    Bob’s.
4.  Alice uses the script that is the preimage to the *mast\_hash* value
    of her input UTXO. Generally speaking, this script has the same
    format as in step 2.e and she can compute her randomized public key
    from her original public key and the ciphertext *ctxt*. The variable
    \$transaction is automatically assigned the encoding of all input
    and output UTXOs. Alice provides a signature for the \$signature
    variable.
5.  Alice uses the *amt* value of her input UTXO, along with the same
    value from both outputs, to generate a non-interactive
    zero-knowledge proof establishing that:

    a.  All output commitments are commitments to positive numbers;

    b.  The input is the sum of the outputs.

6.  The transaction consists of Alice’s input UTXO, both output UTXOs,
    the script and signature, and the zero-knowledge proof. Alice
    broadcasts this transaction to the network.

How the Pledge Works
--------------------

The Pledge is a native data structure for repayment contracts. It was
designed with three objectives in mind: 1) cultivation of reputation
based on repayment history; 2) access control with regards to payments;
3) anonymity with respect to authorized payers.

### Pledge Structure

The Pledge is a contract agreed upon by the following parties:

-   Lender or Payee
-   Borrower or Payer
-   Originator

All parties to the contract sign the Pledge using their identity key.
The contract terms are a list of clauses, each stipulating:

-   The time interval, in term of block heights;
-   The amount to be paid;
-   The *mast\_hash* of the destination;
-   (Optional) the public key of the payment authorizer.

Every *mast\_hash* that occurs in the Pledge has an associated
outstanding spendable balance.

After agreeing to the terms of the Pledge, the participants add their
signatures and broadcast the data structure to the network.

### Paying into a Pledge

In order to make a payment, Alice generates a transaction. The output
UTXO is subtly different than regular ones:

-   It has an explicit amount instead of a commitment to one;
-   The *mash\_hash* is equal to the hash of the Pledge;
-   The *ctxt* is not a ciphertext but a bit string that indicates the
    clause that is satisfied with the payment.

She broadcasts the transaction to the network. As a result, the
outstanding spendable balance of the *mast\_hash* of the indicated
clause is increased by the given amount.

### Paying out of a Pledge

In order to pay out of a Pledge, Bob makes a transaction. The input UTXO
consists of (*amt, ctxt, mast\_hash*) where

-   *amt* is the amount Bob wishes to spend. (The rest is returned to
    the outstanding spendable balance.)
-   *ctxt* is the Pledge hash.
-   *mast\_hash* is the *mast\_hash* from which Bob wants to spend.

The transaction includes an authentication path and satisfying
assignment to the undetermined variables. To prevent replay attacks, the
script verifies a signature on both the transaction and on the block
height. Bob broadcasts the transaction to the network.

### Proxy Repayment with Proxy Re-signatures

With the proxy re-signature scheme, only those parties that have
received the proxy information can make payments into the Pledge.
Depending on who the authorizer is, more parties than just Alice can
make valid payments. In particular, if Alice is the authorizer, she can
generate proxy information for *any* identity public key. That person
can then generate payments with signatures that, after the proxy
transformation, are valid under the authorizer public key.

### Computing Reputation

All Pledges and all transactions to them are public and stored on the
blockchain. It is possible therefore to compute for each identity public
key a list of obligations that that party entered into. Furthermore, it
is possible to determine which of those obligations were kept and which
were broken, along with extra information such as the dates of those
events and the average transaction fee at those points in time. These
data points are the typical inputs to your favorite formula for
computing a payment reputation score.

How Pledge Chaining Works
-------------------------

### Pledge Update

A Pledge update allows Bob to trade spending rights to a Pledge. It is a
message, broadcast to the network, consisting of:

-   The Pledge hash of the Pledge to be updated;
-   The *mast\_hash* to be replaced;
-   The new *mast\_hash*, possibly provided to Bob by Charlie;
-   An authentication path for the old *mast\_hash* and assignments to
    the undetermined variables.

Typically, *mast\_hash* commits to a simple script that verifies a given
signature on a known message -- a transaction or the pledge update --
against a hardcoded public key. If the script evaluates to True then all
occurrence of the old *mast\_hash* in the Pledge are replaced by the new
*mast\_hash*, and the outstanding spendable balance is transferred.

### Chaining

Pledge Chaining allows Bob to automatically redirect incoming payments
from one Pledge where he is the Payee, to another Pledge where he is the
Payer, or to engineer more complicated automatic cash flows. To link two
Pledges, Bob broadcasts a Pledge update, replacing his *mast\_hash* not
with a new one *mast\_hash* but with PVM bytecode. This smart contract
can then forward the incoming funds to the right address public key or
secondary Pledge payment, possibly after performing other computations.
